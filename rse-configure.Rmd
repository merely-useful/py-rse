# Configuring Software {#rse-configure}

## Questions {#rse-configure-questions}

```{r, child="questions/rse-configure.md"}
```

## Introduction {#rse-configure-intro}

The Jupyter Notebook, PyCharm and other interactive tools
are great for prototyping code and exploring data,
but in many cases you will ultimately want to take the code you've developed
using those tools and apply it to thousands of data files, 
run it with many different parameters,
and/or combine it with other programs in a data analysis pipeline. 
In order to do these things,
it is often necessary/preferable to turn the code you've developed into a program 
that works like any other Unix command-line tool.

When creating a command line program,
the modern Unix convention is to provide four levels of configuration:

1.  A system-wide configuration file for general settings.
2.  A user-specific configuration file for personal preferences.
3.  A job-specific file with settings for a specific run.
4.  Command-line options to change things that commonly change.

This is sometimes called [overlay configuration](glossary.html#overlay-configuration)
because each level overrides the ones above it:
the user's configuration file overrides the system settings,
the job configuration overrides the user's defaults,
and the command-line options overrides that.

In this chapter we will learn how to write a Python script
(i.e. a command line program written in Python)
and apply the four levels of configuration.


## Command line programs {#rse-configure-cmdline}

In general, the first thing that gets added to any Python script is the following:

```python
if __name__ == '__main__':
    main()
```

The reason we need these two lines of code
is that running a Python script in bash is very similar to importing that file in Python. 
The biggest difference is that we donâ€™t expect anything to happen when we import a file, 
whereas when running a script we expect to see some output
(e.g. an output file, figure and/or some text printed to the screen).

The `__name__` variable exists to handle these two situations.
When you import a Python file `__name__` is set to the name of that file
(e.g. when importing script.py, `__name__` is `script`),
but when running a script in bash `__name__` is always set to `__main__`.
The convention is to call the function that produces the output `main()`,
but you can call it whatever you like.

The next thing you'll need is a library to parse the command line for input arguments.
The most widely used option is 
[argparse](https://docs.python.org/3/library/argparse.html).

Putting those together,
here's a basic python script for us to start with:

```shell
$ cat script.py
```

```python
import argparse

#
# All your functions (that will be called by main()) go here.
#

def main(inargs):
    """Run the program."""

    print('log file is:', inargs.logfile)
    print('quiet mode is:', inargs.quiet)


if __name__ == '__main__':

    description='Example script.'
    parser = argparse.ArgumentParser(description=description)
    
    parser.add_argument("--logfile", type=str, help="log file", default=None)
    parser.add_argument("--quiet", action="store_true", default=False, help="quiet mode")

    args = parser.parse_args()            
    main(args)
```

By running `script.py` at the command line
we'll see that `argparse` handles all the input arguments:

```shell
$ python script.py --logfile log.txt
```

```text
log file is: log.txt
quiet mode is: False
```

It also generates help information for the user:

```shell
$ python script.py -h
```

```text
usage: script.py [-h] [--logfile LOGFILE] [--quiet]

Example script.

optional arguments:
  -h, --help         show this help message and exit
  --logfile LOGFILE  log file
  --quiet            quiet mode
```

and issues errors when users give the program invalid arguments:

```shell
$ python script.py log.txt
```

```text
usage: script.py [-h] [--logfile LOGFILE] [--quiet]
script.py: error: unrecognized arguments: log.txt
```


## How can I manage configuration files consistently? {#rse-configure-files}

Controlling programs from the command line is useful,
but complex programs can have many different configuration options,
and it's very useful to be able to save settings in a file for later reference
(and reproducibility).
Enabling a program to read its configuration from a file
also allows users to set values once and then not worry about them,
which is particularly useful when they're installing the software on their own computer
and want to put temporary files in a different location
or change the value of the alpha parameter for fitting curves.

Programmers have invented many formats for configuration files,
so please do not create your own.
A popular format is [YAML](glossary.html#yaml),
which stands for "Yet Another Markup Language".
Since YAML is used in [GitHub Pages](glossary.html#github-pages),
and (unlike JSON) allows comments,
we'll explore it in this section.

Here's a sample configuration file:

```shell
$ cat config.yml
```

```text
# Example configuration file
logfile: "/tmp/log.txt"
quiet: false
overwrite: false
fonts:
- Verdana
- Serif
```

And here's a short Python program that reads and prints that configuration:

```shell
$ cat read_config.py
```

```python
import yaml

with open('config.yml', 'r') as reader:
    config = yaml.load(reader)
print(config)
```

```shell
$ python read_config.py
```

```text
{'logfile': '/tmp/log.txt', 'quiet': False, 'overwrite': False, 'fonts': ['Verdana', 'Serif']}
```

Simple YAML files are simple to write:

1.  Lines starting with `#` are comments.
2.  A line `key: value` defines a value for the given key.
    Values can be numbers,
    `true` or `false`,
    or quoted strings.
    (Strings don't actually have to be quoted in every case,
    but the file is a lot easier to understand if you always use quotes.)
3.  A point-form list underneath a key becomes an array of values.

When a file like this is read in Python,
the result is a dictionary.
YAML allows nested keys and lists,
but if you need them,
you're probably doing something wrong @Xu2015:
most users never use most configuration options and find their presence confusing.


## How can I implement overlay configuration? {#rse-configure-overlay}

We said at the start that programs often have
system-wide, per-user, and per-job configuration files,
with each overriding values from the one(s) before
and command-line parameters overriding the rest.
We can implement this using `dict.update`,
which updates one dictionary with values from another:

```shell
$ cat util.py
```

```python
import yaml

def get_full_configuration(filenames, command_line={}):
    '''
    Overlay configuration files and command-line parameters,
    returning configuration object.
    '''
    result = {}
    for f in filenames:
        with open(f, 'r') as reader:
            config = yaml.load(reader)
            result.update(config)
    result.update(command_line)
    return result
```

This function creates an empty dictionary to hold settings.
It then reads each specified configuration file in turn
and updates the result dictionary with whatever it found in that file.
If a file defines values that were previously defined in an earlier file,
the `update` method call automatically overwrites the older values.
We end by overriding what we read from the files with whatever was given on the command line;
we'll have to convert `argparse`'s output to a dictionary,
but that's straightforward using the built in function `vars()` 

We can test this with these three configuration files
(`system.yml`, `user.yml`, `job.yml`),

```shell
$ cat system.yml
```

```text
# System configuration file
quiet: true
```

```shell
$ cat user.yml
```

```text
# User configuration file
quiet: false
logfile: "/tmp/log.txt"
```

```shell
$ cat job.yml
```

```text
# Job specific configuration file
logfile: "./complaints.txt"
```

by updating `script.py` from earlier:

```shell
$ cat script.py
```

```python
import argparse
from util import get_full_configuration

config_files = ['system.yml', 'user.yml', 'job.yml']

def main(inargs):
    """Run the program."""

    config = get_full_configuration(config_files, command_line=vars(inargs))
    print(config)

if __name__ == '__main__':

    description='Example script.'
    parser = argparse.ArgumentParser(description=description,
                                     argument_default=argparse.SUPPRESS)
    
    parser.add_argument("--logfile", type=str, help="log file")
    parser.add_argument("--quiet", action="store_true", help="quiet mode")

    args = parser.parse_args()            
    main(args)
```

```shell
$ python script.py --quiet
```

```text
{'quiet': False, 'logfile': './complaints.txt'}
```

## How can I find configuration files? {#rse-configure-find}

Our configuration files will usually not all be in the same directory.
System-wide settings for an application called `app` are often stored in `/etc/app.yml`.
Alternatively,
some programs will set an environment variable APP to the name of the installation directory,
and then read the system configuration file from `$APP/app.yml`.
We can use `os.getenv('APP')` to get the value of the environment variable `APP`,
then append `app.yml` and load that.
(Older programs often use the name `app.rc`,
where "rc" stands for "resource control".)

Similarly,
we can get personal settings from `$HOME/.app.yml`;
the leading '.' hides the configuration file from `ls`.
Finally,
per-job settings can come from `app.yml` in the current directory,
where again "app" is replaced with the name of the program.
Here's a utility routine that constructs and checks these filenames:

```python
def find_config_files(name):
    '''
    Construct a list of configuration files for the named application.
    '''
    app_yml = name + '.yml'
    locations = [(name.upper(), app_yml),
                 ('HOME', '.' + app_yml),
                 ('PWD', app_yml)]
    result = []
    for (var, filename) in locations:
        value = os.getenv(var)
        if value:
            path = os.path.join(value, filename)
            if os.path.isfile(path):
                result.append(path)
    return result
```

Note that we use `os.path.isfile` to check that file exists before trying to read it.


## How can I keep a record of the actual configuration that produced particular results? {#rse-configure-dump}

Careful record keeping is essential to reproducible science,
and if *we* are careful,
the computer can do the record keeping.
We can save the entire (merged) configuration object for a particular run of a program
using `yaml.dump`.
If we have written our configuration functions correctly,
this will let us re-create configuration on another machine
even if it has different default settings.
The test is whether our program can load a dumped configuration,
then dump it again and get the same result.

If we're going to do this,
we should always include a version number as a field in the dumped configuration;
our program should also print this out when given a `--version` flag.
We need this because how we interpret options will change over time,
and if you don't know what the version of the program was,
we'll have to guess what options mean.



## Exercises {#rse-configure-exercises}

### Read configuration solely from file

-   FIXME: implement flag to read entire configuration from file *and nothing else*.




## Key Points {#rse-configure-keypoints}

```{r, child="keypoints/rse-configure.md"}
```

```{r, child="./links.md"}
```
